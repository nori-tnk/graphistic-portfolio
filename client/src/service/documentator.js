/**
 * Provides document generation service based on data
 */
export default class DocService {
  constructor(config, graphManager) {
    this.title = config.title;
    this.h2 = config.h2;
    this.siteUrl = config.siteUrl;
    this.name = config.name;
    this.country = config.country;
    this.specialDataConversion = config.specialDataConversion;
    this.graphManager = graphManager;
  }

  generateMarkdownFrom(data) {
    const md = [];
    md.push(`# ${this.title}`);
    md.push(this.supplyAutoGenMessage());
    md.push(`## Profile`);
    md.push(`### Identity`);
    md.push(`${this.name}, *${this.country}*`);
    md.push(`### Knowledge/experience stack`);
    md.push(this.supplyNodeCount());
    md.push(this.produceDataSection(data, 3));

    return md.join("\n\n");
  }

  supplyAutoGenMessage() {
    return `This report was auto-generated by "the graph-app" on [this web site](${this.siteUrl}).`;
  }

  supplyNodeCount() {
    const numSelection = this.graphManager.uiStateManager.getSelectedNodes()
      .length;
    const numNodes = this.graphManager.nodes.length;
    return `${numSelection} out of ${numNodes} entries were picked up.`;
  }

  produceDataSection(data, nestingOffset) {
    let markdown = "";
    let _nestingOffset = nestingOffset || 0;

    const produceHeading = (nesting, k) => {
      return "#".repeat(nesting + _nestingOffset + 1) + " " + k + "\n\n";
    };

    const produceLine = (v) => {
      return v + "\n\n";
    };

    const flattenObject = (o) => {
      let markdown = produceHeading(o.nesting, o.heading);
      Object.entries(o.body).forEach(([k, v]) => {
        switch (typeof v) {
          case "string":
            markdown += produceHeading(o.nesting + 1, k) + produceLine(v);
            break;
          case "object":
            if (v instanceof Array) {
              markdown += flattenArray({
                nesting: o.nesting + 1,
                heading: k,
                body: v,
              });
              break;
            }
            markdown += flattenObject({
              nesting: o.nesting + 1,
              heading: k,
              body: v,
            });
            break;
          default:
            console.warn("Unsupported type", typeof v);
        }
      });

      return markdown;
    };

    const flattenArray = (o) => {
      let markdown = produceHeading(o.nesting, o.heading);
      o.body.forEach((v) => {
        switch (typeof v) {
          case "string":
            markdown += produceLine(`* ${v}`);
            break;
          default:
            console.warn("Unsupported type", typeof v);
        }
      });

      return markdown;
    };

    const produceFirstPart = (title, label, url) => {
      const _title = url ? `[${title}](${url})` : title;
      return (
        "#".repeat(_nestingOffset + 1) + " " + _title + "\n\n" + label + "\n\n"
      );
    };

    const produceRelationshipsPart = (name, id) => {
      let relsPart = `#`.repeat(_nestingOffset + 2) + " Relationships\n\n";
      const rels = this.graphManager.getRelationshipsOf(id);

      // `rels` should be in the form of: {from: [{label:label, nodes: ["name", "name",]}, {<alike>}], to: [<alike>] }
      relsPart += Object.entries(rels).reduce((accum, [fromTo, list]) => {
        const relGroup = list.reduce((accum, rel) => {
          let joinedNodes;
          if (1 < rel.nodes.length) {
            joinedNodes = [
              rel.nodes.slice(0, -1).join(", "),
              rel.nodes[rel.nodes.length - 1],
            ].join(" and ");
          } else {
            joinedNodes = rel.nodes[0];
          }

          const _label = convertSpecialData("rel", "label", rel.label);
          const seeds = [name, `*${_label}*`, joinedNodes];
          const sentence =
            fromTo === "from" ? seeds.join(" ") : seeds.reverse().join(" ");
          return accum + `* ${sentence}\n`;
        }, "");
        return accum + relGroup;
      }, "");
      return relsPart;
    };

    const convertSpecialData = (elementType, k, v) => {
      this.specialDataConversion[elementType].forEach((entry) => {
        if (entry[k] === v) {
          v = entry.substitution;
        }
      });
      return v;
    };

    let restMarkdown = "";
    data.forEach((datum) => {
      const entry = {};
      restMarkdown = "";
      Object.entries(datum).forEach(([k, v]) => {
        let nesting = 0;
        switch (k) {
          case "id":
          case "name":
          case "labels":
          case "url":
            entry[k] = convertSpecialData("node", k, v);
            break;
          default:
            switch (typeof v) {
              case "string":
                restMarkdown += produceHeading(nesting + 1, k) + produceLine(v);
                break;
              case "object":
                if (v instanceof Array) {
                  restMarkdown += flattenArray({
                    nesting: nesting + 1,
                    heading: k,
                    body: v,
                  });
                } else {
                  restMarkdown += flattenObject({
                    nesting: nesting + 1,
                    heading: k,
                    body: v,
                  });
                }
              default:
                console.warn("Unsupported type", typeof v);
            }
        }
      });

      markdown += produceFirstPart(entry.name, entry.labels, entry.url);
      markdown += restMarkdown;
      markdown += produceRelationshipsPart(entry.name, entry.id);
      markdown += "\n\n";
    });
    return markdown;
  }
}
